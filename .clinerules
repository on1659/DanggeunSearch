# Code Rules for DanggeunSearch (Svelte + Express)

## 1. 비동기 처리 (CRITICAL)

### 병렬 실행
- **독립적인 작업은 Promise.all()로 병렬 처리**
```js
// ❌ 순차 실행 (느림)
const user = await fetchUser()
const posts = await fetchPosts()

// ✅ 병렬 실행 (빠름)
const [user, posts] = await Promise.all([fetchUser(), fetchPosts()])
```

### await 지연
- **await은 실제로 필요한 시점까지 미루기**
```js
// ❌ 조건문 밖에서 await
const data = await fetchData()
if (condition) {
  return data.value
}

// ✅ 필요한 분기에서만 await
const dataPromise = fetchData()
if (condition) {
  const data = await dataPromise
  return data.value
}
```

### API 라우트 최적화
```js
// ❌ 순차 await
export async function handler(req, res) {
  const user = await getUser(req.userId)
  const prefs = await getPreferences(req.userId)
  res.json({ user, prefs })
}

// ✅ 프라미스 먼저 시작, 나중에 await
export async function handler(req, res) {
  const userPromise = getUser(req.userId)
  const prefsPromise = getPreferences(req.userId)
  const [user, prefs] = await Promise.all([userPromise, prefsPromise])
  res.json({ user, prefs })
}
```

## 2. 번들 최적화 (CRITICAL)

### 배럴 파일 금지
```js
// ❌ 배럴 임포트 (전체 번들 포함)
import { Button } from './components'

// ✅ 직접 임포트
import { Button } from './components/Button.svelte'
```

### 동적 임포트
```js
// ❌ 무거운 라이브러리 정적 임포트
import Chart from 'chart.js'

// ✅ 사용 시점에 동적 로드
const Chart = await import('chart.js')
```

### 조건부 모듈 로딩
```js
// ❌ 사용 안 할 수도 있는데 미리 로드
import { analytics } from './analytics'
if (userOptedIn) analytics.track()

// ✅ 사용할 때만 로드
if (userOptedIn) {
  const { analytics } = await import('./analytics')
  analytics.track()
}
```

## 3. 서버 성능 (HIGH)

### 인증 필수
- **모든 API 엔드포인트에 인증 검사**
```js
// ❌ 인증 없음
app.post('/api/update', async (req, res) => {
  await db.update(req.body)
})

// ✅ 인증 먼저
app.post('/api/update', async (req, res) => {
  if (!req.session?.userId) return res.status(401).end()
  await db.update(req.body)
})
```

### 직렬화 최소화
- **클라이언트에 필요한 데이터만 보내기**
```js
// ❌ 전체 객체 전송
res.json({ user })

// ✅ 필요한 필드만
res.json({ name: user.name, email: user.email })
```

## 4. JavaScript 성능 (MEDIUM)

### Set/Map 활용
```js
// ❌ 배열 includes (O(n))
const allowedIds = [1, 2, 3, 4, 5]
if (allowedIds.includes(userId)) { ... }

// ✅ Set (O(1))
const allowedIds = new Set([1, 2, 3, 4, 5])
if (allowedIds.has(userId)) { ... }
```

### 루프 최적화
```js
// ❌ 객체 속성을 매번 접근
for (let i = 0; i < items.length; i++) {
  console.log(items[i].data.value)
}

// ✅ 캐싱
for (let i = 0, len = items.length; i < len; i++) {
  const value = items[i].data.value
  console.log(value)
}
```

### 정규식 호이스팅
```js
// ❌ 루프 안에서 RegExp 생성
items.forEach(item => {
  if (/pattern/.test(item)) { ... }
})

// ✅ 루프 밖으로
const pattern = /pattern/
items.forEach(item => {
  if (pattern.test(item)) { ... }
})
```

### 불변성 (toSorted)
```js
// ❌ 원본 배열 변경
const sorted = items.sort()

// ✅ 새 배열 반환
const sorted = items.toSorted()
```

### 조기 종료
```js
// ❌ 불필요한 처리
function process(items) {
  let result = []
  for (const item of items) {
    result.push(transform(item))
  }
  return result
}

// ✅ 빈 배열 체크
function process(items) {
  if (items.length === 0) return []
  let result = []
  for (const item of items) {
    result.push(transform(item))
  }
  return result
}
```

## 5. 프로젝트별 규칙

### 당근마켓 크롤링
- Rate limit 준수 (분당 5회)
- 캐시 활용 (30분)
- __remixContext JSON 파싱 에러 처리 필수

### Express API
- 에러 핸들링 미들웨어 사용
- CORS 설정 확인
- 환경변수 검증

---

**원칙:**
- 성능 > 편의성
- 병렬 > 순차
- 직접 임포트 > 배럴 임포트
- 캐싱 > 반복 계산
